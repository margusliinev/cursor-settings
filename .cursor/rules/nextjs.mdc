---
description: Rules for writing Next.js code
globs: **/*.ts, **/*.tsx
alwaysApply: false
---

# Next.js Rules

## Project Structure

-   **`app/`**: App Router directory containing routing files
    -   `page.tsx`: UI for a route
    -   `layout.tsx`: Shared layout for a route and its children
    -   `loading.tsx`: Loading UI while route segment loads
    -   `error.tsx`: Error boundary for a route segment
    -   `not-found.tsx`: Custom 404 UI for a route segment
    -   `route.ts`: API route handlers (GET, POST, PUT, DELETE)
    -   `[slug]`: Dynamic route segments
    -   `[...slug]`: Catch-all segments, `[[...slug]]`: Optional catch-all
    -   `(folder)`: Route groups (organize without affecting URL)
-   **`components/`**: Reusable UI components (`ComponentName.tsx`)
-   **`lib/`**: Utilities, helpers, and third-party integrations
-   **`hooks/`**: Custom React hooks (`useHookName.ts`)
-   **`types/`**: TypeScript type definitions
-   **`public/`**: Static assets (images, fonts, etc.)

## Server vs Client Components

-   **Server Components (default):** Render on server, access backend directly, smaller bundle size
-   **Client Components:** Require `'use client'` directive, enable interactivity and React hooks

**Use Server Components for:** Data fetching, backend access, reducing bundle size
**Use Client Components for:** Interactivity (onClick, onChange), hooks (useState, useEffect), browser APIs

### Server Component

```tsx
// app/posts/page.tsx
export default async function PostsPage() {
    const posts = await fetch('https://api.example.com/posts').then((res) => res.json());

    return (
        <div>
            <h1>Posts</h1>
            {posts.map((post) => (
                <article key={post.id}>
                    <h2>{post.title}</h2>
                    <p>{post.excerpt}</p>
                </article>
            ))}
        </div>
    );
}
```

### Client Component

```tsx
// components/CommentForm.tsx
'use client';

import { useState } from 'react';

export default function CommentForm({ postId }: { postId: string }) {
    const [comment, setComment] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setIsSubmitting(true);

        await fetch('/api/comments', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ postId, comment }),
        });

        setComment('');
        setIsSubmitting(false);
    };

    return (
        <form onSubmit={handleSubmit}>
            <textarea value={comment} onChange={(e) => setComment(e.target.value)} required />
            <button type='submit' disabled={isSubmitting}>
                {isSubmitting ? 'Submitting...' : 'Submit'}
            </button>
        </form>
    );
}
```

### Composing Server and Client Components

```tsx
// app/posts/[id]/page.tsx
import CommentForm from '@/components/CommentForm';

export default async function PostPage({ params }: { params: Promise<{ id: string }> }) {
    const { id } = await params;
    const post = await fetch(`https://api.example.com/posts/${id}`).then((res) => res.json());

    return (
        <article>
            <h1>{post.title}</h1>
            <p>{post.content}</p>
            <CommentForm postId={id} />
        </article>
    );
}
```

## Routing

### Basic Page

```tsx
// app/blog/page.tsx
export default function BlogPage() {
    return <h1>Blog</h1>;
}
```

### Layout (Shared UI)

```tsx
// app/blog/layout.tsx
export default function BlogLayout({ children }: { children: React.ReactNode }) {
    return (
        <div>
            <nav>Blog Navigation</nav>
            <main>{children}</main>
        </div>
    );
}
```

### Loading State

```tsx
// app/blog/loading.tsx
export default function Loading() {
    return <div>Loading blog...</div>;
}
```

### Error Boundary

```tsx
// app/blog/error.tsx
'use client';

export default function Error({ error, reset }: { error: Error & { digest?: string }; reset: () => void }) {
    return (
        <div>
            <h2>Something went wrong!</h2>
            <button onClick={reset}>Try again</button>
        </div>
    );
}
```

### Not Found Page

```tsx
// app/blog/not-found.tsx
export default function NotFound() {
    return <h2>Blog post not found</h2>;
}
```

### Dynamic Routes

```tsx
// app/blog/[slug]/page.tsx
export default async function BlogPostPage({ params }: { params: Promise<{ slug: string }> }) {
    const { slug } = await params;
    const post = await getPost(slug);

    return (
        <article>
            <h1>{post.title}</h1>
            <p>{post.content}</p>
        </article>
    );
}
```

### API Routes

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server';

export async function GET() {
    const posts = await db.post.findMany();
    return NextResponse.json(posts);
}

export async function POST(request: Request) {
    const data = await request.json();
    const post = await db.post.create({ data });
    return NextResponse.json(post, { status: 201 });
}
```

## Data Fetching

### Rendering Strategies

-   **Static (default):** Generated at build time, cached and reused
-   **Dynamic:** Generated at request time for personalized content

**A route becomes dynamic when using:** `cookies`, `headers`, `connection`, `draftMode`, `searchParams`, `unstable_noStore`, or `fetch` with `{ cache: 'no-store' }`

### Static Data (Cached)

```tsx
// app/products/page.tsx
export default async function ProductsPage() {
    // Cached by default
    const products = await fetch('https://api.example.com/products').then((res) => res.json());

    return (
        <div>
            {products.map((product) => (
                <div key={product.id}>{product.name}</div>
            ))}
        </div>
    );
}
```

### Revalidated Data (ISR)

```tsx
// app/products/page.tsx
export default async function ProductsPage() {
    // Revalidate every 60 seconds
    const products = await fetch('https://api.example.com/products', {
        next: { revalidate: 60 },
    }).then((res) => res.json());

    return (
        <div>
            {products.map((product) => (
                <div key={product.id}>{product.name}</div>
            ))}
        </div>
    );
}
```

### Dynamic Data (No Cache)

```tsx
// app/dashboard/page.tsx
export default async function DashboardPage() {
    // Always fresh
    const stats = await fetch('https://api.example.com/stats', {
        cache: 'no-store',
    }).then((res) => res.json());

    return <div>Active users: {stats.activeUsers}</div>;
}
```

### Parallel Fetching

```tsx
// app/dashboard/page.tsx
export default async function DashboardPage() {
    const [user, posts, comments] = await Promise.all([
        fetch('https://api.example.com/user').then((res) => res.json()),
        fetch('https://api.example.com/posts').then((res) => res.json()),
        fetch('https://api.example.com/comments').then((res) => res.json()),
    ]);

    return (
        <div>
            <h1>{user.name}</h1>
            <p>{posts.length} posts</p>
            <p>{comments.length} comments</p>
        </div>
    );
}
```

### Client-Side Fetching with TanStack Query

```tsx
// app/providers.tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode } from 'react';

const queryClient = new QueryClient();

export default function Providers({ children }: { children: ReactNode }) {
    return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}
```

```tsx
// components/UserProfile.tsx
'use client';

import { useQuery } from '@tanstack/react-query';

export default function UserProfile({ userId }: { userId: string }) {
    const { data, isLoading, error } = useQuery({
        queryKey: ['user', userId],
        queryFn: async () => {
            const res = await fetch(`/api/users/${userId}`);
            if (!res.ok) throw new Error('Failed to fetch');
            return res.json();
        },
    });

    if (isLoading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div>
            <h2>{data.name}</h2>
            <p>{data.email}</p>
        </div>
    );
}
```

```tsx
// components/CreatePostForm.tsx
'use client';

import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useState } from 'react';

export default function CreatePostForm() {
    const [title, setTitle] = useState('');
    const queryClient = useQueryClient();

    const mutation = useMutation({
        mutationFn: async (newPost: { title: string }) => {
            const res = await fetch('/api/posts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newPost),
            });
            return res.json();
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['posts'] });
            setTitle('');
        },
    });

    return (
        <form
            onSubmit={(e) => {
                e.preventDefault();
                mutation.mutate({ title });
            }}
        >
            <input value={title} onChange={(e) => setTitle(e.target.value)} required />
            <button type='submit' disabled={mutation.isPending}>
                {mutation.isPending ? 'Creating...' : 'Create'}
            </button>
        </form>
    );
}
```

## Server Actions & Forms

Server Actions enable server-side mutations with progressive enhancement (works without JavaScript).

### Basic Server Action

```tsx
// app/actions.ts
'use server';

import { revalidatePath } from 'next/cache';

export async function createPost(formData: FormData) {
    const title = formData.get('title') as string;
    const content = formData.get('content') as string;

    await db.post.create({ data: { title, content } });

    revalidatePath('/posts');
}
```

### Server Action in Server Component

```tsx
// app/posts/new/page.tsx
import { createPost } from '@/app/actions';

export default function NewPostPage() {
    return (
        <form action={createPost}>
            <input name='title' required />
            <textarea name='content' required />
            <button type='submit'>Create Post</button>
        </form>
    );
}
```

### Server Action in Client Component

```tsx
// components/CreatePostForm.tsx
'use client';

import { useActionState } from 'react';
import { createPost } from '@/app/actions';

export default function CreatePostForm() {
    const [state, formAction, isPending] = useActionState(createPost, null);

    return (
        <form action={formAction}>
            <input name='title' required />
            <textarea name='content' required />
            <button type='submit' disabled={isPending}>
                {isPending ? 'Creating...' : 'Create Post'}
            </button>
            {state?.error && <p>{state.error}</p>}
        </form>
    );
}
```

## Metadata & SEO

```tsx
// app/blog/layout.tsx or page.tsx
import type { Metadata } from 'next';

export const metadata: Metadata = {
    title: 'My Blog',
    description: 'A blog about web development',
    keywords: ['Next.js', 'React', 'Web Development'],
};
```

## Images & Fonts

### Image Optimization

```tsx
import Image from 'next/image';

export default function Avatar() {
    return <Image src='/avatar.png' alt='User avatar' width={100} height={100} priority />;
}
```

### Font Optimization

```tsx
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
        <html lang='en' className={inter.className}>
            <body>{children}</body>
        </html>
    );
}
```
